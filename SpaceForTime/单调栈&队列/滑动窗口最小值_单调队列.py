# _*_ coding: utf-8 _*_
"""
@Date:       2024/8/23 0:23
@Author:     wz
@File:       滑动窗口最小值_单调队列.py
@Decs:
"""


class Solution:
    def function(self, nums, k):
        q = []  # 单调队列（队列内是数组索引）
        res = []
        for i in range(len(nums)):  # 遍历nums
            # 队列不为空 && 且滑动窗口应该滑动 队首元素需要出队
            while q and i - q[0] + 1 > k:
                q.pop(0)  # 队头抛出

            # 队列不为空 && 且不符合单调的性质 队尾元素需要出队
            # 滑动窗口最小值：当nums[q[-1]] > nums[i]时，队尾元素大于当前元素时，出队，维护单调队列严格递增，
            #              则队头元素每次保存位置时滑动窗口的最小值
            # 滑动窗口最大值：当nums[q[-1]] < nums[i]时，队尾元素小于当前元素时，出队，维护单调队列严格递减，
            #       说明每次添加新元素的时候，队头元素是滑动串口内最大的，则队头元素每次保存位置时滑动窗口的最大值

            # key：为什么单调队列可以找到最值的关键在这里。单调队列存储的那些可能成为当前或未来窗口最值的候选元素。
            #   对于寻找区间内最小值情况时，把单调队列里的元素逐一和当前元素比较，大于当前元素的值肯定是要pop掉，或者直到队列为空
            while q and nums[q[-1]] > nums[i]:
                q.pop(-1)  # 队尾抛出
            # 加入当前元素下标，又因为在加入当前元素的时候，前面已经把大于当前元素的值都pop掉了，所以队列自然单调
            q.append(i)

            if i + 1 >= k:
                res.append(nums[q[0]])  # 而又因为单调队列存储的是可能成为当前或未来窗口最值的候选元素、且单调，所以队头就是答案
        return res


if __name__ == "__main__":
    nums = [1, 3, -1, -3, 5, 3, 6, 7]
    k = 3
    s = Solution()
    print(s.function(nums, k))
