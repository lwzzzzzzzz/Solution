### 空间换时间的技巧
与一般来说的哈希表考察问题相似，实质上有很多数据结构都是通过空间换时间，只不过适用场景不同而已。

- ####差分数组 Differential Queues
    
    差分数组适用于对list有反复的加减操作的情况，比如上下车问题，航班航线问题。 \
    
  > 举个例子:\
  > 当有5个乘客在1号站台上车，3号有4人下车，那对于乘客数量这个list，需要对[x,_x,x,x,x_]，先遍历对1后面都加5，再对3后面都减4；\
    但对于差分数组，我们可以[x,_5,0,-4_,x]来表示，第一个5表示在前面的基础上该位置下标需要加5，后续因为没有上车也没有下车，则为0，对于前面位置不增不减；在下标3有4人下车，则对应标记为-4，对前面位置减少4人，最后原数组累加差分数组就是结果，用差分数组的空间换了反复迭代累加的时间

  **其模式在于将每一个位置相对前一个位置应该加上（或减去）的数的`df`列表统计出来，最后再通过原数组还原出修改后数组。\
  `res[i] - res[i-1] = df[i]`**
    
  ```python
  df = [0 for i in range(n)]  # 找到有多少个位置
  for start, end, cnt in bookings:  # 遍历题中每一个case
      df[start] += cnt  # 起始位置 +cnt
      if end < n:  # 判断有没有终止位置
          df[end] -= cnt  # 终止位置 -cnt  （复位操作）

  res = [0 for i in range(len(df))]  # 给一个有同样长度的初始化结果
  
  # 经典还原原数组
  res[0] = df[0]  # 初始化结果
  for i in range(1, n):
      res[i] = res[i - 1] + df[i]
  return res
  ``` 

- ####单调栈 Monotonic Stacks
    
  单调栈适用于对list前面某些下标的结果依赖后面某个下标的结果。比如每日温度问题。 
  > 也举个例子：\
  > 当我想知道要过几天后面天气才会比今天高时，显然当前结果依赖后续某个状态，一般来说，确定一个列表内的所有元素的前后关系，需要两个for循环完成，但是这里用空间换时间的方式。 \
  > 通过一个栈来存储前面的元素，在遍历后面的时候，当发现满足关系即出栈算出结果并存储，用出栈来代替一次for循环为前面元素寻找关系，直到遍历完成
  ```python
  res = [0 for _ in range(len(temperatures))]
  stack1 = []  # 栈内单调递减
  for i in range(len(temperatures)):
      # 当遍历到的元素比栈顶元素大的话，找到了栈顶元素根据题意的结果；同理对于栈内所有元素，当满足下标i位置和栈顶元素满足条件，反复出栈返回结果
      while stack1 and temperatures[stack1[-1]] < temperatures[i]:
          peek = stack1.pop(0)  # 处理栈顶元素，返回栈顶元素下标
          res[peek] = i - peek
      stack1.append(i)  # 下标入栈
  return res
  ``` 